##### 1.innodb 与myisam

innodb 是行级锁，myisam是表级锁，频繁写用innodb 频繁读用myisam
innodb 支持事务，myisam不支持事务
innodb 支持外键，myisam不支持外键
myisam的索引以表名+.MYI文件分别保存。
innodb的索引和数据一起保存在表空间里    

##### 2.mysql 查询缓存

配置query_cache_type 

| 值   | 效果         |
| ---- | ------------ |
| 0    | 不使用缓存   |
| 1    | 始终使用缓存 |
| 2    | 按需使用缓存 |



##### 3.事务隔离级别

低级别的隔离级别一般支持更高的并发处理，并拥有更低的系统开销

###### 1 Read uncommitted (读未提交)

（1）所有的事务都可以看到其他未提交事务的执行结果

（2）本隔离级别很少实际应用，因为他的性能不必其他级别好多少

（3）该级别引发的问题是---脏读（dirty read）读取到了未提交的数据

 比如事务A读到了事务B还未提交的内容

###### 2 Read Committed 读取提交内容

（1）这是大多数数据库系统默认的隔离级别（但不是mysql默认的）

（2）一个事务只能看见已经提交的事务所做出的改变

（3）这种隔离级别出现的问题是--不可重复读：不可重复读意味这我们在同一个事务中执行完全相同的select语句时可能看到

不一样的结果。有一个交叉的事务有了新的commit,导致了数据的改变；（一个数据库被多个实例操作时，同一个事务的其他实力在该实例处理期间可能会有新的额commit）



###### 3可重复读

(1)这是mysql 默认事务的隔离级别

（2）它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行

（此级别可能出现的问题，幻读）当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行。当用户再读取该范围的数据行时，会发现有新的“幻影行”

（4）innodb 和falcon存储引擎通过多版本并发控制（mvcc）机制解决了该问题；

###### 4可串行化

（1）这是最高的隔离级别

（2）它过强制事务排序，使之不可能互相冲突，从而解决了幻读的问题，简而言之，他是在每个读的数据行上加上了共享锁。

（3）在这个级别，可能导致大量的超时现象和锁竞争















##### 4.mysql 范式



##### 5索引



##### 6分库分表



##### 7主从复制，读写分离



##### 8死锁是怎么产生的









