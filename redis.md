##### 1.什么是redis

redis 是单线程一个key-value 类型的内存数据库，很想memcached,整个数据库加载在内存中操作。   

6.0 之后引入了多线程，但是这个多线程处理的只是网络 数据读写和协议的解析这部分占用了大量的时间，把网络改成多线程会性能会有很大的提升，

执行命令仍然是单线程。之所以这么设计是不想 Redis 因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。



##### 2.redis 相比memcached 有哪些优势

（1） 

| 值   | 效果         |
| ---- | ------------ |
| 0    | 不使用缓存   |
| 1    | 始终使用缓存 |
| 2    | 按需使用缓存 |



##### 3.缓存穿透和缓存雪崩

线上禁止使用keys * 命令

dbsize 统计key 总数可以在线上使用，时间复杂读O（1）有一个寄存器专门存储



###### 2redis 持久化

RDB 内存快照，生成rdb 文件命令save,阻塞，bgsave fork紫子进程非阻塞

AOF 操作日志



###### 3分布式

(1)主从复制， slaveof ip port 可以使用命令也可以修改配置



（2）它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行

（此级别可能出现的问题，幻读）当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行。当用户再读取该范围的数据行时，会发现有新的“幻影行”

（4）innodb 和falcon存储引擎通过多版本并发控制（mvcc）机制解决了该问题；

###### 4redis 事务

（1）这是最高的隔离级别

（2）它过强制事务排序，使之不可能互相冲突，从而解决了幻读的问题，简而言之，他是在每个读的数据行上加上了共享锁。

（3）在这个级别，可能导致大量的超时现象和锁竞争

事务的四大特性：

原子性，一致性，隔离性，持久性



##### 4.mysql 范式

第一范式：数据表的每一列都要保持他的原子特性，也就是列不能再分割

第二范式：属性必须完全依赖于主键，有主键，非主键字段依赖于主键

第三范式：每列都于主键有直接关系不存在传递依赖

BC范式 主属性不依赖于主属性；



##### 5索引

###### 1索引的分类

（1）单列索引，普通索引，唯一索引，主键索引，组合索引，全文索引（只支持myisam），和空间索引(myisam)

组合索引遵循左前缀原则；

###### 2聚簇索引和非聚簇索引

B+Tree 结构都可以用在myisam 和innodb上。

（1）myisam的是非聚簇索引，B+Tree的叶子节点上的data ,并不是数据本身，而是数据存放的地址，主索引和辅助索引没啥区别，只是主索引中的key一定是唯一的，这里的索引都是非聚簇索引，两颗b+树看上去没有什么不同，主键索引的树存储的是主键，辅助索引的树存储的键是辅助键。

innodb使用的是聚簇索引，将主键组织到一颗B+树中，而数据就叶子结点的data上。

聚簇索引的数据物理存放位置与索引的顺序是一样的，只要索引是相邻的，那么数据一定也是相邻的存放在磁盘上，聚簇索引的查询效率比非聚簇索引的查询效率要高的多，

非聚簇索引

###### 3 索引失效情况

（1）未使用左前缀

（2）类型转换 字符串要使用引号

（3）搜索一个索引而在另一个索引上做了order by 操作

（4）在索引列上的操作使用MySQL的函数





##### 6分库分表



##### 7主从复制，读写分离



##### 8死锁是怎么产生的









